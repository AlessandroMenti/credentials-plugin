== User guide
:experimental:

This document provides guidelines for using the Credentials API.

This document is structured as follows:

* The first section provides dome background into the use cases driving the development of the Credentials API.

* The second section is an overview of all the functionality provided by the Credentials API.

* The subsequent sections consider how to use the different pieces of functionality provided by the Credentials API.

=== Background

In the ideal world, we wouldn't need any secrets in order to build and deploy software or perform any of the other automation tasks that Jenkins can be co-opted into.

But the reality is that in almost all cases even something as basic as building software requires at least one secret:

* You need a SCM username/password to checkout the source code to build

Once you start using Jenkins for more than just Continuous Integration, you are going to find more and more use cases for needing to share secrets with Jenkins:

* Building the release version of the application requires signing the application using a code signing key.
* Deploying the application to staging requires the credentials for the staging environment
* Deploying the application to production requires the credentials for the production environment
* Updating the issue tracker with details of relevant Jenkins builds requires credentials for the issue tracker
* etc.

Before the introduction of the Credentials API plugin (in early 2012), each Jenkins plugin was responsible for managing their own credentials.
This meant that you would have to give the Subversion plugin a username and password, you would also need to give the JIRA plugin a username and password, etc.
Perhaps the biggest issue would occur every 45-90 days...
We should all know that https://pages.nist.gov/800-63-3/[the current NIST standards] recommend against enforced periodic password rotation, but a lot of corporate IT SECURITY policies still mandate it.
So your password has changed, welcome to hell where you have to race to change all the places that you stored that password in Jenkins before it attempts to use the old password more than three times causing your account to be locked out, phone up the help-desk, get your password reset _again_ and repeat.

This exact use case was the driver for the initial development of the Credentials API plugin.

With the Credentials API plugin, we get:

* An API for plugin authors to use to define credential types
* An API for plugin authors to use to integrate external credentials stores with Jenkins
* An API for plugin authors to use to retrieve credentials from credentials stores (transparently integrating the internal/external credentials stores)
* A UI for users to manage the credentials available to Jenkins.

For the Jenkins user, this means that when the password (or other secret) needs updating, they only have to update it once and all the plugins that have been using those credentials will immediately switch to the new password, lockout prevented.

.The Jenkins-internal credentials store
[WARNING]
====
While the Credentials API plugin provides a default _internal_ credentials store, the intent is that other, more secure, _external_ credentials stores will provide integrations with the Credentials API.

If you are using the _internal_ credentials store to store *high value* credentials then you will need to lock down your Jenkins configuration:

* Apply all of the recommendations from the  https://wiki.jenkins.io/display/JENKINS/Securing+Jenkins[Securing Jenkins] wiki page.
* No builds on the master (ideally zero executors)
* Probably use the https://plugins.jenkins.io/authorize-project[Authorize Project plugin] to control effective permission of running builds.
* etc.

If a non-trusted user can gain access to the files in the `JENKINS_HOME/secrets` directory, then it is game over.

image::images/use-case-intro.png[scaledwidth="40%",width="300px"]

While the above security recommendations are generally valid for any situation where Jenkins has access to *high value* credentials, because:

* the _internal_ store is stored in the `JENKINS_HOME`
* the _internal_ store is encrypted using a key that is also stored in `JENKINS_HOME`
* the JVM running Jenkins must have access to these files

It becomes critical to secure the filesystem of the Jenkins master process.

With an _external_ credentials store, access to the Jenkins master filesystem will not generically compromise credentials.
In the event of a breach, the last-accessed tracking facilities of an enterprise-grade external store will enable identification of _at risk_ credentials in need of rotation.
====

=== Overview

In order to understand how to manage credentials with the Credentials API plugin, you need to understand a number of Jenkins concepts:

* Contexts within Jenkins
* Authentication within Jenkins
* The Jenkins security model

The Credentials API plugin introduces some more concepts:

* Credentials types
* Credentials scopes
* Credentials domains
* Credentials providers
* Credentials stores

There are three ways to manage credentials with the Credentials API:

* Through the Web UI
* Through the REST API
* Through the Jenkins CLI

The holy grail is that each credentials selection lists will display exactly the relevant credentials:

image::images/ideal-select-population.png[scaledwidth="90%"]

==== Contexts within Jenkins

Jenkins implements a hierarchical context model.
Every context within Jenkins has a chain of parent contexts leading ultimately to the root context.

The root context is Jenkins itself.
Plugins can define additional child contexts, for example the https://plugins.jenkins.io/cloudbees-folder[Folders plugin] adds the Folder context, but by default Jenkins provides the following child contexts from the root context:

Jobs:: Each job is its own context, the individual builds of a job could be considered as child contexts, but no plugins currently make use of that potential.
Users:: Each user recorded by Jenkins has their own context.
Build agents:: Build agents have their own context, though this is typically not really relevant from the point of view of credentials.
Views:: Views have their own context. It is important to note that jobs are only weakly associated with views, they are not child contexts of the views they are members of.

The hierarchical nature of contexts becomes more relevant once plugins such as the https://plugins.jenkins.io/cloudbees-folder[Folders plugin] are installed as then you can have more complex trees of jobs.

==== Authentication within Jenkins

Jenkins is a multithreaded application.
Each execution thread has an associated authentication.
There are three classes of authentication that a thread can be associated with:

* `ACL.SYSTEM` this is the super-user authentication of the Jenkins master process itself.
Also known as `SYSTEM`.
Any actions performed by Jenkins itself will start in a thread using this authentication.
* A user authentication, this type of authentication is assigned to any web/CLI requests by a logged in user.
Additionally, plugins like https://plugins.jenkins.io/authorize-project[Authorize Project plugin] can be used to configure jobs to run as specific users or even as the user that triggered the job.
* `Jenkins.ANONYMOUS` this is the authentication of a web/CLI request that has not been authenticated.
Also known as `ANONYMOUS`.
Additionally, plugins like https://plugins.jenkins.io/authorize-project[Authorize Project plugin] can be used to configure jobs to run as `ANONYMOUS`.

==== The Jenkins security model

Jenkins uses a permissions based security model.
Different operations have different permissions.
Plugins can define their own permissions.

To determine whether an operation can be performed, Jenkins asks the currently configured authorization strategy whether a specific authentication has the required permission in a specific context.

The authorization strategy is an extension point and there are multiple plugins providing their own implementations.
In most cases, these strategies are mostly hierarchical, so if an authentication has a permission in a parent context it will typically have the same permission in the children of that context.

[NOTE]
====
Authorization strategies that provide for use-cases such as secret skunkworks projects may provide for removal of permissions from child contexts.
====

In short, each authorization strategy is provided with the :

* Permission requested
* Authentication requesting
* Context of request

And returns a `yes` / `no` answer.

==== Credentials types

Most people tend to think of there being only 5 or 6 types of credentials / secrets:

* Password
* Username and password
* SSH private key
* Public Certificate and private key
* Binary blob data
* That OAuth thingy

If we wanted to take things further, we could abstract them all away into some secret bytes and a list of non-secret named properties.

From the point of view of somebody implementing a credentials management system, it is indeed tempting to reduce credentials down to this basic primitive.
From the perspective of users and Jenkins, the reduction may end up throwing away useful information to assist in selecting the correct credentials to use for different situations.

For example, technically you could choose to store the SSH private key in the "password" field of a Username and Password (assuming there is no upper limit on password length).
How would a user know that `wecoyote/*****` is the password credential while `wecoyote/*****` is the one that shoved the SSH private key into the password field?
How would Jenkins know whether to try the password field contents as a password or as a SSH private key?

Different plugins will provide different credentials types.

How are we supposed to determine which type to use?

You should choose the type based on the ability for the underlying secret to be consumed by other systems.
This principle is best illustrated by examples:

* _What credentials type should I choose for entering my username and password for use to update the issue tracker?_
+
So the thing about issue trackers is that very often they can be integrated with the corporate single-sign-on service.
If that is the case, then there is a realistic chance that I might need to reuse the username and password to authenticate with the source control system, etc.
Thus, we probably should prefer the more generic _Username and password_ credentials type, because the secret will likely be used by other plugins.

* _What credentials type should I choose for entering my username and application token for use to update the issue tracker?_
+
Application tokens are typically generated by a service and associated with a user account.
They are designed to take the place of a password for that specific service and typically they will only ever be displayed one time to the user.
The user can see the details of last use for each application tokens and can choose to revoke the application token at any time.
In this case there is zero chance of the application token being used by another service.
We should use the most specific credentials type supported by the plugins we are using.
So if there is a _Acme Corp Issue Tracker Application Token_ credentials type provided by the _Acme Corp Issue Tracker_ plugin, even though the application token is logically equivalent to a password, we should choose the specific credentials type.
If the plugin doesn't provide a dedicated credentials type, then in that case we would fall back to Username and Password and we would likely have to leverage <<credentials-domains,Credentials Domains>> to try and recreate some of the contextual information that a service specific credentials can provide.

[NOTE]
====
The Jenkins Administrator can configure which credentials types are actually permitted to be used in a Jenkins instance using the menu:Jenkins[Manage Jenkins > Configure Credentials] screen
====

==== Credentials scopes

Each credentials instance in the Credentials API plugin has an associated scope.
The scope defines how the credentials can be exposed.

System scope::
This scope is only available in credentials stores associated with the root context.
System scope credentials are exposed to the Jenkins system / background tasks.
For example, a system scoped credential can be used to connect a build agent or to globally manage post-commit web hooks in a source control system.

Global scope::
This scope is the default scope.
Global scope credentials are exposed to their associated context and all child contexts.
If you want credentials to be generally available to jobs, use Globals scope.

User scope::
This scope is the only scope available in the per-user credentials store.
User scope credentials are only available to threads using that user's authentication.

There are also two _hidden_ permissions that interact with credentials scopes:

* https://github.com/jenkinsci/credentials-plugin/blob/dc35d4d99f9d4e9bf5fd434aee4f6e1bfca4c47d/src/main/java/com/cloudbees/plugins/credentials/CredentialsProvider.java#L144[`Credentials/UseOwn`] which by default is implied by the `Item/Build` permission but can be turned into a distinct permission with the system property `com.cloudbees.plugins.credentials.UseOwnPermission`.
* https://github.com/jenkinsci/credentials-plugin/blob/dc35d4d99f9d4e9bf5fd434aee4f6e1bfca4c47d/src/main/java/com/cloudbees/plugins/credentials/CredentialsProvider.java#L160[`Credentials/UseItem`] which by default is implied by the `Job/Configure` permission but can be turned into a distinct permission with the system property `com.cloudbees.plugins.credentials.UseItemPermission`.

[NOTE]
====
By default, and unless the https://plugins.jenkins.io/authorize-project[Authorize Project plugin] has been installed, jobs running in Jenkins will be running as `ACL.SYSTEM` and will only be able to access global scoped credentials.

If you install the https://plugins.jenkins.io/authorize-project[Authorize Project plugin] and configure a job to run as a specific user, the credentials available to that job will now be determined by that user's permissions in the context of that job.
If the user does not have either `Credentials/UseOwn` (normally implied by `Item/Build`) or `Credentials/UseItem` (normally implied by `Job/Configure`) then the job will be unable to access any credentials at all.
====

If a user has `Credentials/UseOwn` permission in a specific context then they are allowed to use their user scoped credentials for actions performed with their authentication in that context.
For example, jobs running as the user's authentication will have access to that user's user scoped credentials if and only if the user has `Credentials/UseOwn` permission in the context of that job.

If a user has `Credentials/UseItem` permissions in a specific context then they are allowed to use the global scoped credentials for actions performed with their authentication in that context.
For example, jobs running as the user's authentication will have access to the global scoped credentials available in the context of that job if and only if the user has `Credentials/UseItem` in the context of that job.

[[credentials-domains]]
==== Credentials domains

The ideal case for managing credentials with the Credentials API plugin is that each service that you have to interact with has a distinct independent secret lifecycle and a dedicated service specific credentials type.
In other words:

* The secret used to connect to one service is never (other than accidentally) the same as the secret used to connect to any other service.
* Resetting the secret for one service will never trigger a reset of the secrets for other services (procedurally you might have to reset them all after say a security breach, but they are not inherently linked)

So, for example, you might have:

* a Google Authentication type that stores credentials used to interact with Google's services;
* an AWS Authentication type that stores credentials used to interact with AWS;
* a Twitter Authentication type that stores the credentials used to tweet about releases after they have been deployed to Google or AWS;
* a GitHub Authentication type that stores the credentials used to connect to GitHub;
* etc

Now the above would be OK, because - unless there are some corporate mergers - we do not expect the secret used to connect to Google to be the same as the secret used to connect to AWS or Twitter or GitHub.

In the enterprise world, typically the services can be moved in-house and with single-sign-on will likely end up using username and password credentials.

Not every system will integrate with single-sign-on though, so it is likely that there will be multiple username and password credentials with the same username but for different systems.

How can we recover the "type" information that we lost when we selected _Username and Password_?

The answer is _Credentials Domains_.

You define a credentials domain and you provide a specification.
The specification will be something like:

* Only hostname `myservice.example.com`
* Only URLs with the `https` protocol
* Only on port 8443

Now when the credentials API is asked to list up relevant credentials it will exclude credentials from domains that do not match.

[NOTE]
====
Pay *very* close attention.

"Excluding credentials from domains that do not match" is _not_ the same as "Only including credentials from domains that do match".
====

By initially, there is only one credentials domain, the global domain.
The global domain has no specification, so credentials in the global domain will always match any set of domain requirements.

.Example
****
If we have credentials in four different domains:

global::
 Global domain
secure-service::
A domain with the specification: hostname is `myservice.example.com`; protocol is `https`; port is `443`.
public-service::
A domain with the specification: hostname is `myservice.example.com`; protocol is `http`; port is `80`.
source-control::
A domain with the specification: hostname is `myscm.example.com`; protocol is `https`; port is `443`.

We start typing in the URL of the service we want to connect to.

Initially the URL is empty, so the drop-down list will show credentials from all four domains.

Suppose we now have typed in `https://`, at this point the requirements are just that the protocol is `https`, so as *public-service* has a specification of `http` it is excluded from the drop-down list.

Suppose we now type in `https://myservice.example.com`, at this point we have the requirements are: protocol is 'https' and hostname is 'myservice.example.com', so both *public-service* and *source-control* are now excluded.

Finally, suppose we had typed in `myservice.example.com`, in this case we exclude only `source-control` as the requirements are just that the hostname is `myservice.example.com`

In all cases, the credentials from the *global* domain are always present.
****

[TIP]
====
The use-case for credentials domains is to provide a way for the user to provide information about the services with which the credentials are expected to work.

Credential domains are intended to help select correct credentials for each services.

Credential domains are not intended to prevent credentials from being used against the wrong services.

In some cases, the domain requirements of a credential cannot be determined, such as when using a credentials parameter or when using a plugin that has not fully implemented the recommendations of the link:consumer.adoc[consumer guide].

In order to ensure that users can actually select the required credentials in these cases, the Credentials API needs to return credentials from all domains, which is why we use _Excluding credentials from domains that do not match_.

Because of the above: *Credential domains are not intended to restrict access to credentials.*

If you need to restrict access to credentials put those credentials in a context that limits their usage, e.g. create a "Deployment" folder and put the keys for deploying into the "Deployment" folder, restrict access to the "Deployment" folder to only those users permitted to deploy.
====

==== Credentials providers

The Jenkins extension point `CredentialsProvider` is responsible for connecting Jenkins to an external credentials vault.

Not everyone will be exposing *high value* credentials to Jenkins.
Similarly, not everyone needs the complexity of an enterprise credentials vault.
For people who do not need to use an enterprise credentials vault, the Credentials API plugin provides two credentials providers and the https://plugins.jenkins.io/cloudbees-folder[Folders plugin]

[NOTE]
====
The Jenkins Administrator can configure which credentials providers are actually permitted to be used in a Jenkins instance using the menu:Jenkins[Manage Jenkins > Configure Credentials] screen
====

The standard credentials providers are:

System Credentials Provider::
** This credentials provider exposes a credentials store at the root context.
** The credentials store supports credentials domains.
** The credentials store supports two scopes: *system* and *global*.
** The credentials store can be inspected from menu:Jenkins[Credentials>System].

User Credentials Provider::
** This credentials provider exposes a per-user credentials store for each user.
** The credentials store supports credentials domains.
** The credentials store only supports *user* scope.
** The credentials store can be inspected from either menu:Jenkins[__username in the banner bar__>Credentials>User] or  menu:Jenkins[People>__username__>Credentials>User].
** A user cannot access the per-user credentials store of another user.

The https://plugins.jenkins.io/cloudbees-folder[Folders plugin] adds the following credentials provider:

Folder Credentials Provider::
** This credentials provider exposes a per-folder credentials store in the context each folder.
** The credentials store supports credentials domains.
** The credentials store only supports *global* scope which will expose the credentials to any children of the folder.
** The credentials store can be inspected from menu:Jenkins[__folder name__>Credentials>Folder]

==== Credentials stores

Credentials providers expose credentials to Jenkins through the credentials store extension point.

* A credentials store is associated with a specific context within Jenkins.
* A credentials store either only supports the global domain or has full support for custom domains.
* A credentials store will support a defined list of credentials scopes.
* Some credentials stores are read-write and others are essentially read-only derived from a computation.
* _Internal_ credentials stores will be responsible for storing the actual credentials.
* _External_ credentials stores can work in a number of different ways depending on the backing external service:
** In some cases the external service provides essentially a flat namespace of credentials without any ability to infer structure or list available credentials.
+
In these cases the external credentials store will hold the credentials identifiers and any categorization within credentials domains.
+
In some cases the credentials store may need to store additional metadata in order to reconstruct the Jenkins credentials.
** In some cases the external service provides a very rich metadata model and query language.
+
Jenkins can leverage a metadata property to associate credentials with the different Jenkins contexts and perhaps even with infer credentials domains.
+
This type of credentials store is typically read-only though an advanced implementation may be able to create credentials in the external vault and thereby present as a read-write store.

=== Managing credentials

The Credentials API plugin defines three classes of context within Jenkins where the credential can be exposed:

1. The Jenkins root object itself
2. A folder within Jenkins
3. A user within Jenkins

[NOTE]
.Credential scope
====
When exposing a credentials from the Jenkins root object, you will also need to decide what scope to give the exposed credentials.

* Using the `SYSTEM` scope will allow the credentials to be used for launching Jenkins agents as well as for some secondary system wide processes configured through the menu:Jenkins[Manage Jenkins > Configure Jenkins] screen.
The credential will not be available to jobs within Jenkins.

* Using the `GLOBAL` scope will, in addition to the usage permitted by `SYSTEM` scope, will make the credential available to all jobs within Jenkins running as an authentication that has the `Credentials/UseItem` permission.
====

[TIP]
.Understanding the Authorize Project Plugin and Credentials
====
Jenkins associates an authentication with all internal operations.

When a user makes a request from the web browser or from the Jenkins CLI, that request is tagged with the user's authentication and permission checks will restrict the scope of that request to the user's permissions.

The internal operations of Jenkins typically run with the authentication of `SYSTEM` which is the most powerful authentication and has all permissions.

For simple build jobs, this is typically not an issue.
More complex build jobs can involve bi-directional control between Jenkins and the build job.
If the build job has the ability to control Jenkins itself, then the authentication that the build job is running as within Jenkins becomes important.

The https://wiki.jenkins-ci.org/display/JENKINS/Authorize+Project+plugin[Authorize Project plugin] was developed to allow jobs to run with a lesser authentication.

In a Jenkins instance without the Authorize Project plugin (or an alternative plugin providing a http://javadoc.jenkins-ci.org/jenkins/security/QueueItemAuthenticator.html[Queue item authenticator]) the menu:Jenkins[Manage Jenkins > Configure Global Security] screen will not show any Access control for builds options

[id=config-no-authorize-project]
.The Configure Global Security screen without any http://javadoc.jenkins-ci.org/jenkins/security/QueueItemAuthenticator.html[Queue item authenticator] plugins installed
image::images/global-config-no-authorize-project.png[scaledwidth="90%"]

Once at least one http://javadoc.jenkins-ci.org/jenkins/security/QueueItemAuthenticator.html[Queue item authenticator] is installed in the Jenkins instance, then the configuration options will be displayed.

[id=config-authorize-project]
.The Configure Global Security screen with at least one http://javadoc.jenkins-ci.org/jenkins/security/QueueItemAuthenticator.html[Queue item authenticator] plugins installed
image::images/global-config-authorize-project.png[scaledwidth="90%"]

The Access Control for Builds section is an ordered list of http://javadoc.jenkins-ci.org/jenkins/security/QueueItemAuthenticator.html[Queue item authenticator].
The first one that declares an interest in providing authentication for the build job will determine the authentication that the build job will run as.

[id=config-authorize-project-config]
.The Configure Global Security screen adding the https://wiki.jenkins-ci.org/display/JENKINS/Authorize+Project+plugin[Authorize Project plugin]'s http://javadoc.jenkins-ci.org/jenkins/security/QueueItemAuthenticator.html[Queue item authenticator]
image::images/global-config-authorize-project-config.png[scaledwidth="90%"]

To actually use the https://wiki.jenkins-ci.org/display/JENKINS/Authorize+Project+plugin[Authorize Project plugin] you also need to enable it for the specific build job.

[id=job-config-authorize-project]
.Configuring a job to use the https://wiki.jenkins-ci.org/display/JENKINS/Authorize+Project+plugin[Authorize Project plugin]
image::images/job-config-authorize-project.png[scaledwidth="90%"]

Once you switch jobs from running as `SYSTEM` you will encounter a feature of the Credentials API, namely that credentials are only exposed to specific authentications.

There is a permission within the Credentials plugin known as `Credentials/UseItem`.
In order for an authentication to be able to resolve a credentials in either the root scoped store or a folder scoped store, that authentication must have the `Credentials/UseItem` permission.

By default the `Credentials/UseItem` permission is hidden and users receive this permission through implication by the `Job/Configure` permission.
A Jenkins administrator can make the permission visible by defining the `com.cloudbees.plugins.credentials.UseItemPermission` system property with the value of `true`, e.g. by adding `-Dcom.cloudbees.plugins.credentials.UseItemPermission=true` to the Jenkins JVM start-up options.
====

[[credentials-ids]]
.Credentials IDs
[TIP]
====
The Credentials API plugin assigns a semi-unique identifier to every credentials.

It is strongly likely that you will need to reference credentials from pipeline scripts.
Make your life easier and assign the credentials ID rather than relying on the randomly generated UUID.

When giving credentials an ID, remember that the credentials storage may be migrated to an external credentials store.
Because we cannot know _a priori_ what will be valid IDs in an external credentials store it is recommended to follow some basic principles in assigning IDs:

* Keep them less than approximately 40 characters long
* Keep to alpha-numeric with `-`, `_` and `.` as separators
====


==== Creating credentials

===== Using the Jenkins Command Line Interface

The `create-credentials-by-xml` Jenkins CLI command is the command used to expose credentials.

[id=credentials-add-flow-cli-command]
.The Jenkins CLI command for adding credentials to a credentials store.
image::images/add-flow-cli-command.png[scaledwidth="90%"]

Before we can use this CLI command we need to determine the Store Id and Domain.

The Store Id consists of three components separated by the `::`.
The components are  _provider_ `::` _resolver_ `::` _context path_.

The Credentials API provides implementations for three stores, but as the stores are an extension point it is probable best to illustrate the general process for identifying the store id:

1. List the credentials providers:
+
.Listing the credentials providers
----
$ java -jar jenkins-cli.jar -s http://local.example.com/ \
list-credentials-providers
Name                                                                           Provider
============================================================================== ==============================
FolderCredentialsProvider                                                      Folder Credentials Provider
SystemCredentialsProvider                                                      Jenkins Credentials Provider
UserCredentialsProvider                                                        User Credentials Provider
com.cloudbees.hudson.plugins.folder.properties.FolderCredentialsProvider       Folder Credentials Provider
com.cloudbees.plugins.credentials.SystemCredentialsProvider$ProviderImpl       Jenkins Credentials Provider
com.cloudbees.plugins.credentials.UserCredentialsProvider                      User Credentials Provider
folder                                                                         Folder Credentials Provider
system                                                                         Jenkins Credentials Provider
user                                                                           User Credentials Provider
----
+
The each Credentials Provider is exposed using up to three different names (the names are derived by code and simplifications are only exposed if there are no conflicting credentials provider implementations). In the case of the root system credentials store, the most specific provider identifier is `com.cloudbees.plugins.credentials.SystemCredentialsProvider$ProviderImpl` but in the above instance we also have available the short form `system`.

2. List the context resolvers
+
.Listing the context resolvers
----
$ java -jar jenkins-cli.jar -s http://local.example.com/ \
list-credentials-context-resolvers
Name                                                                            Resolves
=============================================================================== =======
ItemContextResolver                                                             Items
SystemContextResolver                                                           Jenkins
UserContextResolver                                                             Users
com.cloudbees.plugins.credentials.CredentialsSelectHelper$ItemContextResolver   Items
com.cloudbees.plugins.credentials.CredentialsSelectHelper$SystemContextResolver Jenkins
com.cloudbees.plugins.credentials.CredentialsSelectHelper$UserContextResolver   Users
item                                                                            Items
system                                                                          Jenkins
user                                                                            Users
----
+
While context resolvers are also an extension point, it is probably unlikely that plugins will find it necessary to define new resolvers in addition to the standard ones.
Normally the context resolvers that we want are either `com.cloudbees.plugins.credentials.CredentialsSelectHelper$SystemContextResolver` (which has the short alias of `system`) or `com.cloudbees.plugins.credentials.CredentialsSelectHelper$ItemContextResolver` (which has the short alias of `item`)
+
If you want to interact with your own per-user credential store then you will want the `com.cloudbees.plugins.credentials.CredentialsSelectHelper$UserContextResolver` (which has the short alias of `user`)

3. Specify the context path
+
* For the `system` context resolver, this is always the fixed value `jenkins`.
* For the `item` context resolver, this is the full name of the item (folder).
The full name is normally the names separated by '/' characters.
The full name is not the URL of the job as that includes `/job/` in the URL.
For example a folder with the URL `http://local.example.com/jenkins/job/example-folder/job/example-sub-folder/` would have the full name `/example-folder/example-sub-folder`
+
[NOTE]
====
The `config.xml` of that folder would - by default - be stored in `$JENKINS_HOME/jobs/example-folder/jobs/example-sub-folder`.

The breadcrumb bar, if the display name has been customized for these folders might look like `Jenkins » Example Folder » Example Sub-Folder`)
====
* For the `user` context resolver, this is the username.

So the some possible Store Id variants are:

* `system::system::jenkins` for the root credentials store
* `folder::item::/full/name/of/folder` for a per-folder credentials store
* `user::user::wecoyote` for the per-user store of Wile E. Coyote, who's username is `wecoyote`.

Next we need to determine the credentials domain that we want to put the credential into.

Next we need to create the XML representation of the credential we want to expose.
The best way to get this is to inspect the configuration of an existing credential of the same type.

If we navigate using a Web browser to find an existing credential, we will end up at an URL something like: `https://jenkins.example.com/credentials/store/system/domain/_/credential/some-credential-id/` by appending `config.xml` to the URL we can see the configuration of that credentials, e.g.:

.Inspecting the `config.xml` of an existing username password credential.
[source,xml]
----
<com.cloudbees.plugins.credentials.impl.UsernamePasswordCredentialsImpl plugin="credentials@2.1.14">
  <scope>GLOBAL</scope>
  <id>some-credential-id</id>
  <description>This is an example username password credential</description>
  <username>wecoyote</username>
  <password>
    <secret-redacted/>
  </password>
</com.cloudbees.plugins.credentials.impl.UsernamePasswordCredentialsImpl>
----

.Inspecting the `config.xml` of an existing SSH private key credential.
[source,xml]
----
<com.cloudbees.jenkins.plugins.sshcredentials.impl.BasicSSHUserPrivateKey plugin="ssh-credentials@1.13">
  <scope>GLOBAL</scope>
  <id>some-credential-id</id>
  <description>This is an example ssh key credential</description>
  <username>wecoyote</username>
  <privateKeySource class="com.cloudbees.jenkins.plugins.sshcredentials.impl.BasicSSHUserPrivateKey$DirectEntryPrivateKeySource">
    <privateKey>
      <secret-redacted/>
    </privateKey>
  </privateKeySource>
</com.cloudbees.jenkins.plugins.sshcredentials.impl.BasicSSHUserPrivateKey>
----

NOTE: when accessing credentials in this way, the secret text will be replaced by `<secret-redacted/>`

So it is just a question of providing our own `config.xml` with the appropriate content.

TIP: When providing the actual secret value, you should exploit the way Jenkins deserializes secrets. If the secret does not decrypt then it is assumed to be the corresponding unencrypted value, which Jenkins will then encrypt before persisting the credentials.

.Example of adding a `deploy-key` credential using the username `wecoyote` and the password `secret123` in the `/example-folder` folder.
[source,bash]
----
$ cat > credential.xml <<EOF
<com.cloudbees.plugins.credentials.impl.UsernamePasswordCredentialsImpl plugin="credentials@2.1.14">
  <scope>GLOBAL</scope>
  <id>deploy-key</id>
  <username>wecoyote</username>
  <password>secret123</password>
</com.cloudbees.plugins.credentials.impl.UsernamePasswordCredentialsImpl>
EOF
$ java -jar jenkins-cli.jar -s https://jenkins.example.com/ \
create-credentials-by-xml folder::item::/example-folder  _ < credential.xml
$ java -jar jenkins-cli.jar -s http://local.example.com/ \
list-credentials folder::item::/example-folder
================================
Domain           (global)
Description
# of Credentials 1
================================
Id               Name
================ ===============
deploy-key       wecoyote/******
================================
----

===== Using the Jenkins REST Interface

To use the REST interface, you need to make a POST request to the `createCredentials` sub-URL of the credentials domain. For example, for the folder `example-folder` in a Jenkins instance hosted at http://local.example.com/ this would be the URL http://local.example.com/job/example-folder/credentials/store/folder/domain/_/createCredentials

.Example of adding a `deploy-key` credential using the username `wecoyote` and the password `secret123` in the `/example-folder` folder.
[source,bash]
----
$ cat > credential.xml <<EOF
<com.cloudbees.plugins.credentials.impl.UsernamePasswordCredentialsImpl plugin="credentials@2.1.14">
  <scope>GLOBAL</scope>
  <id>deploy-key</id>
  <username>wecoyote</username>
  <password>secret123</password>
</com.cloudbees.plugins.credentials.impl.UsernamePasswordCredentialsImpl>
EOF
$ curl -X POST -H content-type:application/xml -d @credential.xml \
https://jenkins.example.com/job/example-folder/credentials/store/folder/\
domain/_/createCredentials
----

NOTE: If your Jenkins instance has CSRF protection enabled or uses authentication then you will need to provide the required headers to the REST request.
Details of the exact headers required depends on the CSRF protection that has been configured and the exact authentication mechanism being used.

==== Removing credentials


===== Using the Web User Interface

Navigate to the Credentials view for the context containing the the credentials to be removed.

There are two ways to remove the credential:

* Use the context menu for the credential and select menu:Delete[]
+
[id=credentials-del-flow-shortcut]
.Using the context menu for removing a credentials from a credentials store.
image::images/del-flow-shortcut.png[scaledwidth="90%"]


* Navigate to the credential and select the menu:Delete[] left hand menu action.
+
[id=credentials-del-flow-long-way]
.Using the credential's menu:Delete[] action directly.
image::images/del-flow-long-way.png[scaledwidth="90%"]

===== Using the Jenkins Command Line Interface

The `delete-credentials` Jenkins CLI command is the command used to remove credentials.

[id=credentials-del-flow-cli-command]
.The Jenkins CLI command for removing credentials from a credentials store.
image::images/del-flow-cli-command.png[scaledwidth="90%"]

.Example of removing the `deploy-key` credential from the global domain of the `/example-folder` folder.
[source,bash]
----
$ java -jar jenkins-cli.jar -s http://local.example.com/ \
delete-credentials folder::item::/example-folder  _ deploy-key
$ java -jar jenkins-cli.jar -s http://local.example.com/ \
list-credentials folder::item::/example-folder
========================
Domain           (global)
Description
# of Credentials 0
========================
Id               Name
================ =======
========================
----

===== Using the Jenkins REST Interface

To use the REST interface, you need to make a DELETE request to the `config.xml` sub-URL of the credentials.
For example, for the `deploy-key` credential in the global domain of the folder `example-folder` in a Jenkins instance hosted at https://jenkins.example.com/ this would be the URL https://jenkins.example.com/job/example-folder/credentials/store/folder/domain/_/credential/deploy-key/config.xml

.Example of removing the `deploy-key` credential from the global domain of `/example-folder` folder.
[source,bash]
----
$ curl -X DELETE  https://jenkins.example.com/job/example-folder/credentials/\
store/folder/domain/_/credential/deploy-key/config.xml
----

NOTE: If your Jenkins instance has CSRF protection enabled or uses authentication then you will need to provide the required headers to the REST request.
Details of the exact headers required depends on the CSRF protection that has been configured and the exact authentication mechanism being used.
